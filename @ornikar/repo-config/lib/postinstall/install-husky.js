// see https://github.com/christophehurpeau/pob/blob/main/%40pob/root/bin/postinstall/install-husky.js

'use strict';

const fs = require('node:fs');
const path = require('node:path');
const husky = require('husky');
const { readYarnConfigFile } = require('../yarn');
const { noPushOnMain } = require('./no-push-on-main');
const { phrasePrePush } = require('./phrase-pre-push');

function createPrepushHook(commands, prePushHookPostContent) {
  const script = `
# get current branch name
currentBranch=$(git rev-parse --abbrev-ref HEAD)

# get current branch ref
branch_ref=$(git symbolic-ref HEAD)

# autodetect main branch (usually master or main)
mainBranch=$(LANG=en_US git remote show origin | grep "HEAD branch" | cut -d' ' -f5)

# z40 is the value matching the empty blob/commit/tree SHA (zero x 40)
z40=0000000000000000000000000000000000000000

while read local_ref local_sha remote_ref remote_sha
do
  if [[ "$local_ref" == "$branch_ref" ]]
  then
    ${noPushOnMain.trim().split('\n').join('\n    ')}
    ${commands.join(' && ')}${
    (prePushHookPostContent || '') &&
    `
    if [ "$?" = 0 ]
    then
      ${prePushHookPostContent}
    fi`
  }
  fi
done
`;
  return `${script.trim()}\n`;
}

const ensureLegacyHuskyConfigDeleted = () => {
  try {
    fs.unlinkSync(path.resolve('husky.config.js'));
  } catch {
    // if legacy husky.config.js doesn't exists, continue
  }
  try {
    fs.unlinkSync(path.resolve('.huskyrc'));
  } catch {
    // if legacy .huskyrc doesn't exists, continue
  }
};

const ensureHuskyNotInDevDependencies = (pkg) => {
  if (pkg.devDependencies && pkg.devDependencies.husky) {
    throw new Error('Found husky in devDependencies. Husky is provided by @ornikar/repo-config, please remove');
  }
};

const writeHook = (hookName, hookContent) => {
  fs.writeFileSync(
    path.resolve(`.husky/${hookName}`),
    `#!/usr/bin/env sh\n. "$(dirname "$0")/_/husky.sh"\n\n# This file is autogenerated by @ornikar/repo-config. Do not change it.\n\n${hookContent.trim()}\n`,
    {
      mode: '755',
    },
  );
};

const ensureHookDeleted = (hookName) => {
  try {
    fs.unlinkSync(path.resolve(`.husky/${hookName}`));
  } catch {
    // if the hook doesn't exists, continue
  }
};

const getPackagesLocations = (pkg) => {
  const isMonorepo = !!pkg.workspaces;

  if (!isMonorepo) return ['.'];
  // eslint-disable-next-line global-require, import/no-extraneous-dependencies
  const { getSyncPackageLocations } = require('@ornikar/monorepo-config');
  const packageLocations = getSyncPackageLocations({ pkg });
  return ['.', ...packageLocations];
};

module.exports = function installHusky({ pkg }) {
  const isYarnPnp = !readYarnConfigFile().includes('nodeLinker: node-modules');

  /* Check legacy */

  ensureLegacyHuskyConfigDeleted();
  ensureHuskyNotInDevDependencies(pkg);

  /* Create Config */

  const shouldRunTest = () => pkg.scripts && pkg.scripts.test;
  const shouldRunChecks = () => pkg.scripts && pkg.scripts.checks;
  const shouldRunCleanCacheOnDependenciesChanges = () =>
    pkg.scripts && pkg.scripts['clean:cache:on-dependencies-changes'];

  try {
    fs.mkdirSync(path.resolve('.husky'));
  } catch {
    // if the directory already exists, continue
  }

  writeHook('commit-msg', 'yarn commitlint --edit $1');
  writeHook(
    'pre-commit',
    `
if [ ! -f node_modules/.bin/ornikar-lint-staged ]; then
  yarn
fi

yarn ornikar-lint-staged
  `,
  );

  const runCleanCache = shouldRunCleanCacheOnDependenciesChanges();
  if (isYarnPnp && !runCleanCache) {
    ensureHookDeleted('post-checkout');
    ensureHookDeleted('post-merge');
    ensureHookDeleted('post-rewrite');
  } else {
    const runYarnInstallOnDiff = `
if [ -n "$(git diff HEAD@{1}..HEAD@{0} -- yarn.lock)" ]; then
  ${[
    // https://yarnpkg.com/features/zero-installs
    isYarnPnp ? '' : 'yarn install --immutable --immutable-cache || true',
    runCleanCache ? 'yarn clean:cache:on-dependencies-changes' : '',
  ]
    .filter(Boolean)
    .join('\n  ')}
fi`;

    let postHookContent = runYarnInstallOnDiff;
    const packageLocations = getPackagesLocations(pkg);

    packageLocations.forEach((packageLocation) => {
      const cdToPackageLocation = packageLocation === '.' ? '' : `cd ${packageLocation}`;
      const cdToRoot = packageLocation === '.' ? '' : `cd ${path.relative(packageLocation, '.')}`;

      const gemfilePath = path.join(packageLocation, 'Gemfile.lock');
      if (fs.existsSync(gemfilePath)) {
        postHookContent += `
if [ -n "$(git diff HEAD@{1}..HEAD@{0} -- ${gemfilePath})" ]; then
  ${[cdToPackageLocation, 'bundle install --path vendor/bundle || true', cdToRoot].filter(Boolean).join('\n  ')}
fi
`;
      }

      const podfilePath = path.join(packageLocation, 'ios/Podfile.lock');

      if (fs.existsSync(podfilePath)) {
        const gitIgnorePath = path.join(packageLocation, '.gitignore');
        if (fs.existsSync(gitIgnorePath) && !fs.readFileSync(gitIgnorePath, 'utf8').includes('/ios/')) {
          postHookContent += `
  if [ -n "$(git diff HEAD@{1}..HEAD@{0} -- ${podfilePath})" ]; then
    ${[cdToPackageLocation, 'yarn pod-install || true', cdToRoot].filter(Boolean).join('\n  ')}
  fi
        `;
        }
      }
    });
    writeHook('post-checkout', postHookContent);
    writeHook('post-merge', postHookContent);
    writeHook('post-rewrite', postHookContent);
  }

  const prePushHookCommands = [];

  if (shouldRunTest()) {
    if (pkg.scripts.test === 'node --test') {
      prePushHookCommands.push('CI=true yarn test');
    } else {
      prePushHookCommands.push('CI=true yarn test --changedSince=origin/$mainBranch');
    }
  }

  if (shouldRunChecks()) {
    prePushHookCommands.push('yarn run checks');
  }

  if (prePushHookCommands.length > 0) {
    let prePushHookPostContent = '';
    const phraseConfigPath = '.phrase.yml';
    if (fs.existsSync(phraseConfigPath)) {
      prePushHookPostContent += phrasePrePush;
    }

    writeHook('pre-push', createPrepushHook(prePushHookCommands, prePushHookPostContent));
  } else {
    ensureHookDeleted('pre-push');
  }

  // skip install husky on CI as we don't need it
  if (!process.env.CI) {
    husky.install('.husky');
  }
};
